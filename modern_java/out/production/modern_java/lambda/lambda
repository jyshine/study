람다 표현식 : 메서드로 전달할 수 있는 익명 함수를 단순화한 것이라고 할 수 있다.
           람다표현식에는 이름은 없지만 파라미터 리스트, 바디, 반환 형식, 발생할 수 있는 예외 리스트를 가질 수 있음.
    -익명
    -함수
    -전달
    -간결성


    ()              ->      {}
    람다 파라미터     화살표     람다 바디


    예시
        boolean => (List<String> list) -> list.isEmpty()
        객체 생성 => () -> new Apple(10)
        객체 소비 => (a) -> {
                    System.out.println(a.getWeight());
                    }
        객체 추출  => (String s) -> s.length()
        값 조합   => (int a, int b) -> a*b
        객체 비교 => (Apple a1, Apple a2) ->
                        a1.getWeight().compareTo(a2.getWeight())

        (String s) -> s.length()

        (Apple a) -> a.getWeight()

        (int x, int y) -> {
            System.out.println("Result :");
            System.out.println(x + y);
            }

        () -> 42

        (Apple a1, Apple a2) -> a1.getWeight().capareTo(a2.getWeight())

함수형 인터페이스
    람다 표현식으로 함수형 인터페이스를 추상 메서드 구현을 직접 전달할 수 있으므로
    전체 표현식을 함수형 인터페이스의 인스턴스로 취급 => 함수형 인터페이스를 구현한 클래스의 인스턴스

함수 디스크립터
    함수형 인터페이스의 추상 메서드 시그니처는 람다 표현식의 시그니처를 가리킨다.
    함다 표현식의 시그니처를 서술하는 메서드를 함수 디스크립터 라고 부른다.

@FunctionalInterface
함수형 인터페이스 가르키는 어노테이션션

순환 패턴 (recurrent pattern) : 자원 처리 패턴으로 자원을 열고 처리한 다음 자원을 닫는 순. 자원 설정, 자원 정리.
어라운드 패턴 (execute around pattern) : 자원 처리하는 코드를 설정과 정리 두 과정이 둘러싸는 형태

함수형 인터페이스 사용
    -Predicate
    -Consumer
    -Function

제너릭 파라미터는 참조형만 사용 가능하다.
박싱(Boxing) 기본형을 참조형으로 변환하는 기능.
언박싱(unboxing) 참조형을 기본형으로 변환하는 반대 동작.
박싱과 언박싱이 자동으로 이루어지는 오토박싱 기능 제공한다.
하지만 이런 변환은 메모리 소모된다.

오토박싱 피할 수 있는 함수형 인터페이스 제공


람다와 함수형 인테페이스 예제

-불리언 표현 Predicate<List<T>>
    (List<String> list) -> list.isEmpty()
-객체 생성 Supplier<T>
    () -> new Apple(10)
-객체에서 소비 Consumer<T>
    (Apple a) -> System.out.println(a.getWeight())
-객체에서 선택/추출 Function<R,T> , ToIntFunction<String> ..
    (String s) -> s.length()
-두 값 조합 IntBinaryOperator
    (int a, int b) -> a*b
-두 객체 비교 Comparator<T> , BiFunction<A,B,Integer>
    (Apple a, Apple b) -> a.getWeight().compareTo(b.getWeight())



예외 처리 예시
